import React                                               from 'react'
import injectSheet                                         from 'react-jss'
import {styles, searchStyles, optionsStyles, optionStyles} from './styles'

const SelectInput = injectSheet(styles)(
  class SelectInput extends React.Component {
    render() {
      const {classes, className, placeholder, name, onInput, onBlur, position} = this.props
      const {options, search, value, searching} = this.state
      return (
        <div className={`${classes.root} ${className || ''}`}>
          <div className={classes.search}>
            <Search
              name={name}
              value={value}
              label={search}
              aria-label={this.props['aria-label']}
              placeholder={placeholder}
              searching={searching}
              inputRef={node => this.input = node}
              searchRef={node => this.searchInput = node}
              handleSearch={e => this.handleSearch(e)}
              onInput={e => {
                if (typeof onInput === 'function') {
                  onInput(e)
                }
              }}
              onFocus={() => {
                this.setState({searching: true})
                this.searchInput.focus()
              }}
              onBlur={e => {
                if (typeof onBlur === 'function') {
                  onBlur(e)
                }
                setTimeout(() => this.setState({searching: false}), 100)
              }}
              onCancel={() => {
                this.setState({label: '', value: '', search: ''})
                this.searchInput.focus()
              }}
            />
          </div>
          <div className={`${classes.options} ${(position === 'static') ? classes.optionsStatic : ''} ${(searching) ? classes.optionsActive : ''}`}>
            <Options
              options={options}
              search={search}
              searching={searching}
              setValue={option => this.updateValue(option)}
            />
          </div>
        </div>
      )
    }

    constructor(props) {
      super(props)
      this.state = {
        options: mapArrayToObjects(props.options),
        search: props.label || '',
        value: props.value || '',
        searching: false,
      }
    }

    updateValue(option) {
      if (!this.input) return
      this.setState({value: option.value, search: option.label})
      this.setNativeValue(this.input, option.value)
      this.setNativeValue(this.searchInput, option.label)
      this.input.dispatchEvent(new Event('input', {bubbles: true}))
      this.input.dispatchEvent(new Event('change', {bubbles: true}))
    }

    handleSearch(e) {
      this.setState({
        search: e.target.value,
      })
    }

    setNativeValue(element, value) {
      const valueSetter = Object.getOwnPropertyDescriptor(element, 'value').set
      const prototype = Object.getPrototypeOf(element)
      const prototypeValueSetter = Object.getOwnPropertyDescriptor(prototype, 'value').set

      if (valueSetter && valueSetter !== prototypeValueSetter) {
        prototypeValueSetter.call(element, value)
      } else {
        valueSetter.call(element, value)
      }
    }
  },
)

const Search = injectSheet(searchStyles)((props) => {
  const {classes, placeholder, searching, searchRef, inputRef, handleSearch, name, label, value, onFocus, onBlur, onCancel, onInput} = props
  return (
    <div className={classes.root}>
      <input
        type="text"
        placeholder={placeholder}
        ref={searchRef}
        onChange={handleSearch}
        value={label}
        onFocus={onFocus}
        onBlur={onBlur}
        className={classes.input}
        aria-label={props['aria-label']}
      />
      <input type="hidden" name={name} value={value} ref={inputRef} onInput={onInput} onChange={onInput}/>
      <div className={classes.actions}>
        {(value || label) && (<button
          type={'button'}
          className={`${classes.action} ${classes.deleteAction}`}
          onClick={e => onCancel(e)}
          aria-label={`Cancel ${props['aria-label']}`}
        />)}
        <button
          type={'button'}
          className={`${classes.action} ${classes.toggleAction} ${(searching) ? classes.close : classes.open}`}
          onClick={e => (searching) ? onBlur(e) : onFocus(e)}
          role={'presentation'}
          aria-label={`Open ${props['aria-label']}`}
        />
      </div>
    </div>
  )
})

const Options = injectSheet(optionsStyles)(({classes, options, setValue, search}) => {
  let items = options.map(option => <Option option={option} onClick={() => setValue(option)} search={search}/>)
  return (
    <div className={classes.root}>
      {React.Children.map(items, item => {
        if (!React.isValidElement(item)) return item
        return React.cloneElement(item)
      })}
    </div>
  )
})

const Option = injectSheet(optionStyles)(({classes, option, onClick, search}) => (
  <div className={`${classes.root} ${(fuzzyMatchOption(search, option)) ? classes.active : classes.inactive}`}
       onClick={onClick}>
    {option.labelComponent || option.label}
  </div>
))

export {SelectInput}

// takes [[value, label], ...] and returns [{value, label}]
function  mapArrayToObjects(arr) {
  if (!arr)
    return []
  if (typeof arr !== 'object')
    throw new Error(`Options must be an array of arrays or objects. \n options = ${JSON.stringify(arr)}`)
  return arr.map(pair => {
    if (Array.isArray(pair)) {
      if (!pair.length || pair.length > 2)
        throw new Error(`Option must be [value, label] or [value, undefined]. \n option = ${JSON.stringify(pair)}`)
      return ({value: pair[0], label: pair[1] || pair[0]})
    } else {
      if (!pair.hasOwnProperty('value'))
        throw new Error(`'Option object must have key 'value'. \n option = ${JSON.stringify(pair, null, 2)}`)
      return pair
    }
  })
  return arr
}

const fuzzyMatchOption = (search, option) => {
  return (fuzzyMatch(search, option.label) || fuzzyMatch(search, option.value))
}

// Fuzzy matching algorithm
// not mine
const fuzzyMatch = function (needle, haystack) {
  if (needle === '' || haystack === '') return true

  needle = needle.toLowerCase().replace(/ /g, '')
  haystack = haystack.toLowerCase()

  // All characters in needle must be present in haystack
  let j = 0 // haystack position
  for (let i = 0; i < needle.length; i++) {
    // Go down the haystack until we find the current needle character
    while (needle[i] !== haystack[j]) {
      j++

      // If we reached the end of the haystack, then this is not a match
      if (j === haystack.length) {
        return false
      }
    }

    // Here, needle character is same as haystack character
    //console.log(needle + ":" + i + " === " + haystack + ":" + j);
  }

  // At this point, we have matched every single letter in the needle without returning false
  return true
}